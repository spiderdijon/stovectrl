esphome:
  name: stovectrl

esp32:
  variant: esp32s3
  framework:
    type: esp-idf

# Enable logging
logger:
  level: VERBOSE

mqtt:
  id: mqtt_client
  broker: 10.11.12.118   # replace with your MQTT broker IP

# Enable Home Assistant API
api:

ota:
  platform: esphome

web_server:
  port: 80

wifi:
  ssid: "Mosh Potats"
  password: "hippopotats123"

uart:
  id: uart_bus
  tx_pin: GPIO17   # Connect to DI of RS485 module
  rx_pin: GPIO18   # Connect to RO of RS485 module
  baud_rate: 9600
  stop_bits: 1
  parity: NONE

modbus:
  id: rs485_bus
  uart_id: uart_bus
  flow_control_pin: 21

modbus_controller:
  - id: amidj14
    address: 0x01       # Default slave ID (check/change via register 0x00FD if needed)
    modbus_id: rs485_bus
    update_interval: 1s
    max_cmd_retries: 0

sensor:
  # --- AI1 ---
  - platform: modbus_controller
    modbus_controller_id: amidj14
    id: ai1_current
    name: "AI1 Current"
    address: 0x00A0
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "mA"
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: template
    name: "Stove Flow Temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    lambda: |-
      if (id(ai1_current).state < 4.0) return NAN;
      return (id(ai1_current).state - 4.0) * (100.0 / 16.0);

  # --- AI2 ---
  - platform: modbus_controller
    modbus_controller_id: amidj14
    id: ai2_current
    name: "AI2 Current"
    address: 0x00A1
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "mA"
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: template
    name: "Stove Return Temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    lambda: |-
      if (id(ai2_current).state < 4.0) return NAN;
      return (id(ai2_current).state - 4.0) * (100.0 / 16.0);

  # --- AI3 ---
  - platform: modbus_controller
    modbus_controller_id: amidj14
    id: ai3_current
    name: "AI3 Current"
    address: 0x00A2
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "mA"
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: template
    name: "Low Loss Header Temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    lambda: |-
      if (id(ai3_current).state < 4.0) return NAN;
      return (id(ai3_current).state - 4.0) * (100.0 / 16.0);
    on_value:
      then:
        - lambda: |-
            static bool pump_on = false;
            if (x > 50.0 && !pump_on) {
              pump_on = true;
              id(mqtt_client).publish("heating/pump/main", "ON");
            } else if (x < 40.0 && pump_on) {   // small hysteresis
              pump_on = false;
              id(mqtt_client).publish("heating/pump/main", "OFF");
            }

  # --- AI4 (0–600 °C) ---
  - platform: modbus_controller
    modbus_controller_id: amidj14
    id: ai4_current
    name: "AI4 Current"
    address: 0x00A3
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "mA"
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: template
    name: "Flue Temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    lambda: |-
      if (id(ai4_current).state < 4.0) return NAN;
      return (id(ai4_current).state - 4.0) * (600.0 / 16.0);

  # --- AI5 (Flow rate in L/min from YF-B10) ---
  - platform: modbus_controller
    modbus_controller_id: amidj14
    id: ai5_current
    name: "AI5 Current"
    address: 0x00A4
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "mA"
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: template
    name: "Stove Flow Rate"
    unit_of_measurement: "L/min"
    accuracy_decimals: 2
    lambda: |-
      if (id(ai5_current).state < 4.0) return 0;
      // Convert 4-20mA → frequency (Hz)
      float frequency = (id(ai5_current).state - 4.0) * (500.0 / 16.0);
      // Convert frequency → flow rate: Q = (F + 8) / 6
      return (frequency + 8.0) / 6.0;

  - platform: template
    name: "Stove Power Output"
    unit_of_measurement: "kW"
    accuracy_decimals: 2
    update_interval: 1s
    lambda: |-
      // Temperatures
      float T1 = id(ai1_current).state < 4.0 ? NAN : (id(ai1_current).state - 4.0) * (100.0 / 16.0);
      float T2 = id(ai2_current).state < 4.0 ? NAN : (id(ai2_current).state - 4.0) * (100.0 / 16.0);

      // Flow in L/min
      float Q  = 0.0;
      if (id(ai5_current).state >= 4.0) {
        float frequency = (id(ai5_current).state - 4.0) * (500.0 / 16.0);
        Q = (frequency + 8.0) / 6.0; // L/min
      }

      // Validate inputs
      if (isnan(T1) || isnan(T2) || Q <= 0) return NAN;

      // ΔT
      float dT = T1 - T2;

      // Thermal power in kW
      return (Q * 69.77 * dT) / 1000.0;


  - platform: modbus_controller
    modbus_controller_id: amidj14
    name: "AI6 Current"
    address: 0x00A5
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  # Digital inputs (bitmask at 0x0090)
  - platform: modbus_controller
    modbus_controller_id: amidj14
    name: "Digital Inputs Raw"
    id: di_raw
    address: 0x0090
    register_type: holding
    value_type: U_WORD

binary_sensor:
  - platform: template
    name: "DI1"
    lambda: |-
      return (int(id(di_raw).state) & 0x01);
  - platform: template
    name: "DI2"
    lambda: |-
      return (int(id(di_raw).state) & 0x02);
  - platform: template
    name: "DI3"
    lambda: |-
      return (int(id(di_raw).state) & 0x04);
  - platform: template
    name: "DI4"
    lambda: |-
      return (int(id(di_raw).state) & 0x08);

switch:
  # Relays (DO, bitmask at 0x0080)
  - platform: modbus_controller
    modbus_controller_id: amidj14
    name: "Relay 1"
    address: 0x0080
    register_type: holding
    bitmask: 0x01

  - platform: modbus_controller
    modbus_controller_id: amidj14
    name: "Relay 2"
    address: 0x0080
    register_type: holding
    bitmask: 0x02

  - platform: modbus_controller
    modbus_controller_id: amidj14
    name: "Relay 3"
    address: 0x0080
    register_type: holding
    bitmask: 0x04

  - platform: modbus_controller
    modbus_controller_id: amidj14
    id: relay_4
    name: "Stove Pump"
    address: 0x0080
    register_type: holding
    bitmask: 0x08

    # --- Automation: Control Relay 4 from AI4 Temperature ---
interval:
  - interval: 1s
    then:
      - lambda: |-
          if (!isnan(id(ai4_current).state)) {
            float T4 = (id(ai4_current).state - 4.0) * (600.0 / 16.0);  // AI4 Temperature
            if (T4 > 100.0) {
              id(relay_4).turn_on();
            } else if (T4 < 90.0) {
              id(relay_4).turn_off();
            }
          }